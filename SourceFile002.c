#pragma config(Sensor, S1,     touchSensor,    sensorNone)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorNone)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          					,    tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void resetGyroSensor(){
	eraseDisplay();
	displayCenteredBigTextLine(2,"Place on table");
	sleep(4000);
	resetGyro(gyroSensor);
	eraseDisplay();
	displayCenteredBigTextLine(2, "Complete.");
	playSound(soundUpwardTones);
	sleep(4000);
}

task main()
{
	resetGyroSensor();
	float kp = 16; // Constant for proportional controllor
	float ki = 0.000075;																			
	float kd = 55;																						
	float offset = 85;																					
	float tp = 0;
	float integral = 0;
	float lasterror = 0;
	float derivative = 0;
	int timer = 0;
	while(1){

		eraseDisplay();

		float gyrovalue = getGyroDegrees(S2);
		displayCenteredBigTextLine(2,"Gyro: %f", gyrovalue);
		float error = gyrovalue - offset;
		integral = integral + error;
		if(integral == 0)
			integral = 0;
		derivative = error - lasterror;
		float Tilt = kp * error + ki*integral + kd*derivative;
		float powerA = (tp + Tilt)* 0.6;
		setMotorSpeed(motorA,powerA);
		setMotorSpeed(motorC,powerA);
		lasterror = error;
	}


}
