#pragma config(Sensor, S1,     touchSensor,    sensorNone)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorNone)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void resetGyroSensor(){
	eraseDisplay();
	displayCenteredBigTextLine(2,"Place on table");
	sleep(4000);
	resetGyro(gyroSensor);
	eraseDisplay();
	displayCenteredBigTextLine(2, "Complete.");
	playSound(soundUpwardTones);
	sleep(4000);
}

task main()
{
	resetGyroSensor();
	float kp = 16; // Constant for proportional controllor			//16
	float ki = 0.00010;																					//0.00010
	float kd = 55;																							//55
	float offset = 88;																					//89
	float tp = 0;
	float integral = 0;
	float lasterror = 0;
	float derivative = 0;
	int timer = 0;
	while(1){

		eraseDisplay();

		float gyrovalue = getGyroDegrees(S2);
		displayCenteredBigTextLine(2,"Gyro: %f", gyrovalue);
		float error = gyrovalue - offset;
		integral = integral + error;
		derivative = error - lasterror;
		float Tilt = kp * error + ki*integral + kd*derivative;
		float powerA = tp + Tilt;
		setMotorSpeed(motorA,powerA);
		setMotorSpeed(motorC,powerA);
		lasterror = error;
	}


}
