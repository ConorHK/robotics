
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Sensor, S4,     remoteSensor,   sensorEV3_IRSensor, modeEV3IR_Remote)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, openLoop, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          leftMotor,     tmotorEV3_Large, openLoop, driveLeft, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Code by Conor Knowles, based on Laurens Balanc3r EV3 tutorial: http://robotsquare.com/2014/07/01/tutorial-ev3-self-balancing-robot/

// Definitions of permanent values
#define WHEEL_DIAMETER = 42; // mm
#define SAMPLE_TIME = 22; // ms (value gotten from source EV3 block code, as of now unaware of purpose)
#define WHEEL_RADIUS = 0.021 // m

// Global variables.
float robotSpeed; // m/s
float robotPosition; // m

// struct definition for variable constants
typedef struct constants {
  float kp;
  float ki;
  float kd;
  float angularVelocity;
  float angle;
  float wheelSpeed;
  float wheelPosition;
} constants;

void initialize() {
  resetMotorEncoder(rightMotor);
  resetMotorEncoder(leftMotor);

  robotSpeed = 0.0; // global
  robotPosition = 0.0; //global
}

constants setConstants(){
  constants initialConstants;

  initialConstants.kp = 0.6;
  initialConstants.ki = 14.0;
  initialConstants.kd = 0.005;
  initialConstants.angularVelocity = 1.3; // gain
  initialConstants.angle = 25.0; // gain
  initialConstants.wheelSpeed = 75.0;
  initialConstants.wheelPosition = 350.0;

  return initialConstants;
}

float position(float prevReferencePosition, float speed){ //TODO speed not used yet
  float referencePosition = (prevReferencePosition + speed) * dt; //TODO undefined variables
  return referencePosition;
}

// updates robot speed and robot position variables.
void readEncoders(){
  long averageEncoderValue = (getMotorEncoder(rightMotor) + getMotorEncoder(leftMotor) / 2);
  robotPosition = WHEEL_RADIUS * averageEncoderValue; // global assignment, wheel radius times average of encoder values

  robotSpeed = WHEEL_RADIUS * getMotorSpeed() / 57.3; //TODO function call not defined and 57.3 not understood.
}

void readGyro(constants currentConstants){ //TODO work out function
  currentConstants.angle;
  currentConstants.angularVelocity;
}

void combineSensorValues(constants currentConstants){
  currentConstants.angularVelocity;
  currentConstants.angle;

  robotSpeed; // global

  robotPosition; //global
  referencePosition; // function call

  return (robotPosition - robotReferencePosition) * gainRobotPosition + robotSpeed * gainRobotSpeed + robotAngle * gainAngle + currentConstants.angularVelocity * gainAngularVelocity; //TODO undefined variables, work out return

}
void readConstants(constants currentConstants){
  /*dt
  ki
  kp
  kd*/
//TODO work out function, not contained in original. gives values to PID.
}

//PID learns from previous error and takes into consideration current state and future state.
//Note: SAMPLE_TIME used in EV3 blocks however i'm unaware what its used for so it is currently left out.
float pid(constants currentConstants, float input, float referenceValue){
  // static float definitions
  static float totalError = 0.0; // total error up till current.
  static float derivative = 0.0; // 'D' of PID.
  static float integral = 0.0; // 'I' of PID, past error.

  float presentError = input - referenceValue; // 'P' of PID.
  totalError += dt * presentError; //TODO dt not defined
  derivative = (presentError - integral) / dt; //TODO dt not defined
  integral = presentError; // set present error to past error for next loop

  return ((currentConstants.kd * derivative) + (totalError * ki) + (presentError * kp);
}

// checks for unaccurate PID output, the result of pid function is passed to this function.
void errors(float output){
  //TODO
}
//TODO function for turning the robot left & right. returns value for setMotorPower
float getSteer(){}

void setMotorPower(float steering, float power){
  //TODO
}

//TODO sleep function? Probably unnecessary.
void wait(){}

//TODO driver code
int main(void){}
