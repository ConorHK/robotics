#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Sensor, S4,     remoteSensor,   sensorEV3_IRSensor, modeEV3IR_Remote)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, openLoop, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          leftMotor,     tmotorEV3_Large, openLoop, driveLeft, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Code by Conor Knowles, based on Laurens Balanc3r EV3 tutorial: http://robotsquare.com/2014/07/01/tutorial-ev3-self-balancing-robot/

// Definitions of permanent values
#define WHEEL_DIAMETER 42 // mm
#define SAMPLE_TIME 22 // ms (value gotten from source EV3 block code, as of now unaware of purpose)
#define WHEEL_RADIUS 0.021 // m
#define SAMPLE_TIME_DIFFERENCE 1.5 // correcting sample time difference for delays created by loop
#define MAX_POWER 100

// Global variables.
float robotSpeed; // m/s
float robotPosition; // m

bool outOfBounds = false;
bool prevOutOfBounds = false;
int outOfBoundsCounter = 0;

float gyroBias;
float gyroRate;

// struct definition for variable constants
typedef struct {
	float dt;
	float kp;
	float ki;
	float kd;
	float angularVelocity;
	float angle;
	float wheelSpeed;
	float wheelPosition;
} constants;


void initialize() {
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);

	robotSpeed = 0.0; // global
	robotPosition = 0.0; //global

	getGyroBias();
}

void setConstants(constants &initialConstants){

	initialConstants.kp = 0.6;
	initialConstants.ki = 14.0;
	initialConstants.kd = 0.005;
	initialConstants.angularVelocity = 1.3; // gain
	initialConstants.angle = 25.0; // gain
	initialConstants.wheelSpeed = 75.0;
	initialConstants.wheelPosition = 350.0;
	initialConstants.dt = (SAMPLE_TIME + SAMPLE_TIME_DIFFERENCE) / 1000.0; // seconds

	return;
}

float getGyroBias(){
	resetGyro(gyroSensor);
	sleep(3000);
	gyroBias = 0.0;

	for(int i = 0; i < 100; i++){
		gyroBias += getGyroRate(gyroSensor);
	}
	gyroBias /= 100; // get average
}

float position(float prevReferencePosition, float speed){
	float referencePosition = (prevReferencePosition + speed) * constants.dt;
	return referencePosition;
}

// updates robot speed and robot position variables.
void readEncoders(){
	long averageEncoderValue = (getMotorEncoder(rightMotor) + getMotorEncoder(leftMotor) / 2);
	robotPosition = WHEEL_RADIUS * averageEncoderValue; // global assignment, wheel radius times average of encoder values

	robotSpeed = WHEEL_RADIUS * ((getMotorSpeed(motorA) + getMotorSpeed(motorB)) / 2) / 57.3;   //TODO?? using average of two motor speeds
}

void readGyro(constants &currentConstants){
	currentConstants.angle;
	currentConstants.angularVelocity;

	static float angleBias = 0.0; // estimate
	float updateRatio = 0.2;
	float currentGyroRate = getGyroRate(gyroSensor);

	gyroBias = gyroBias * (1 - currentConstants.dt * updateRatio) + currentGyroRate * currentConstants.dt * updateRatio;
	gyroRate = currentGyroRate - gyroBias;

	angleBias = angleBias * (1 - dt * updateRatio) - (robotPosition/*TODO */ * ROBOT_POSITION_GAIN  / gainAngle) * dt * updateRatio;

	currentConstants.angle += gyroRate * dt - angleBias;

	return;
}

//Combines all the sensor values for the PID controller
void combineSensorValues(constants currentConstants){
	currentConstants.angularVelocity;
	currentConstants.angle;


	robotSpeed; // global

	robotPosition; //global
	referencePosition; // function call

	return
	( robotPosition - referencePosition ) * contstants.robotPosition +
	currentConstants.robotSpeed * contants.robotSpeed + currentConstants.robotSpeed +
	currentConstants.angle + constants.angle + currentConstants.angularVelocity *
	constants.angularVelocity
}

//PID learns from previous error and takes into consideration current state and future state.
//Note: SAMPLE_TIME used in EV3 blocks however i'm unaware what its used for so it is currently left out.
float pid(constants currentConstants, float input, float referenceValue){
	// static float definitions
	static float totalError = 0.0; // total error up till current.
	static float derivative = 0.0; // 'D' of PID.
	static float integral = 0.0; // 'I' of PID, past error.

	float presentError = input - referenceValue; // 'P' of PID.
	totalError += currentConstants.dt * presentError;
	derivative = (presentError - integral) / currentConstants.dt;
	integral = presentError; // set present error to past error for next loop

	return ((currentConstants.kd * derivative) + (totalError * ki) + (presentError * kp);
}

void setMotorPower(float power){

	if(power > MAX_POWER){  //was using POWER_LIMIT but wasn't defined, changed it to MAX_POWER
		power = MAX_POWER;
		} else if(power < -MAX_POWER){
		power = -MAX_POWER;
	}
	setMotor(rightMotor,power);
	setMotor(leftMotor,power);
}

// checks for unaccurate PID output, the result of pid function is passed to this function.
void errors(float output){
	//Currently uses global variables TODO: static local variables?
	if(abs(pidOutput) > 100){
		outOfBounds = true;
	}

	if( outOfBounds && prevOutOfBounds){
		outOfBoundsCounter++;
		} else {
		outOfBoundsCounter = 0;
	}

	if(outOfBoundsCounter > 20) {
		setMotorPower(0,0);
		sleep(100);
	}
}

void setMotorPower(float power){

	if(power > MAX_POWER){  //was using POWER_LIMIT but wasn't defined, changed it to MAX_POWER
		power = MAX_POWER;
		} else if(power < -MAX_POWER){
		power = -MAX_POWER;
	}
	setMotor(rightMotor,power);
	setMotor(leftMotor,power);
}

//TODO driver code
task main(){

	int increment = 0;
	//PID values
	float pidOutput;
	float pidReference = 0.0; //TODO

	//Values for position
	float referencePosition = 0.0;
	float requestedSpeed = 0.0; //TODO

	float sensors;

	// constants variable
	constants values;


	initialize();
	values = setConstants();

	/* !----Loop-----! */
	resetTimer(T1);
	resetTimer(T2);

	referencePosition = position(referencePosition,requestedSpeed);
	readEncoders(); // update state of robot
	values = readGyro();
	sensors = combineSensorValues(values);

	//PID
	pidOutput = pid(values, sensors, reference);
	errors(pidOutput);
	setMotorPower(pidOutput);

	increment++;

	repeatUntil(getTimer(T2,milliseconds) > SAMPLE_TIME){}
	resetTimer(T2);
}
