#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Sensor, S4,     remoteSensor,   sensorEV3_IRSensor, modeEV3IR_Remote)
#pragma config(Motor,  motorA,          rightMotor,    tmotorEV3_Large, openLoop, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          leftMotor,     tmotorEV3_Large, openLoop, driveLeft, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Code by Conor Knowles and Finbar Ó Deaghaidh, based on Laurens Balanc3r EV3 tutorial: http://robotsquare.com/2014/07/01/tutorial-ev3-self-balancing-robot/

// Definitions of permanent values
#define WHEEL_DIAMETER 42 // mm
#define SAMPLE_TIME 22 // ms (value gotten from source EV3 block code, as of now unaware of purpose)
#define WHEEL_RADIUS 0.021 // m
#define SAMPLE_TIME_DIFFERENCE 1.5 // correcting sample time difference for delays created by loop
#define MAX_POWER 100.00

// Global variables.
float robotSpeed; // m/s
float robotPosition; // m

bool outOfBounds = false;
bool prevOutOfBounds = false;
int outOfBoundsCounter;

float gyroBias;
float gyroRate;

float dt = (SAMPLE_TIME + SAMPLE_TIME_DIFFERENCE) / 1000.0;
float kp = 0.6;
float ki = 14.0;
float kd = 0.005;
float angularVelocity = 1.3;
float angle = 25.0;
// unused float wheelSpeed = 75.0;
// unused float wheelPosition = 350.0;
float balanceRobotSpeed = 75;
float balanceRobotPosition = 350.0;

float pidOutput;


float getGyroBias();

void initialize() {
	resetMotorEncoder(rightMotor);
	resetMotorEncoder(leftMotor);

	robotSpeed = 0.0; // global
	robotPosition = 0.0; //global
	outOfBoundsCounter = 0;

	getGyroBias();
}

float getGyroBias(){
	resetGyro( gyroSensor );
	sleep(3000);
	gyroBias = 0.0;

	for(int i = 0; i < 100; i++){
		gyroBias += getGyroRate(gyroSensor);
	}
	gyroBias = gyroBias / 100; //get average
	return 	gyroBias;

}

float position(float prevReferencePosition, float speed){
	float referencePosition = (prevReferencePosition + speed) * dt;
	return referencePosition;
}

// updates robot speed and robot position variables.
void readEncoders(){
	long averageEncoderValue = (getMotorEncoder(rightMotor) + getMotorEncoder(leftMotor) / 2);
	robotPosition = WHEEL_RADIUS * averageEncoderValue; // global assignment, wheel radius times average of encoder values

	robotSpeed = WHEEL_RADIUS * ((getMotorSpeed(motorA) + getMotorSpeed(motorB)) / 2) / 57.3;   //TODO?? using average of two motor speeds
}

void readGyro(){
	static float angleBias = 0.0; // estimate
	float updateRatio = 0.2;
	float currentGyroRate = getGyroRate(gyroSensor);

	gyroBias = gyroBias * (1 - dt * updateRatio) + gyroRate * dt * updateRatio;
	gyroRate = currentGyroRate - gyroBias;

	angleBias = angleBias * (1 - dt * updateRatio) - (robotPosition * balanceRobotPosition  / angle) * dt * updateRatio;

	angle += gyroRate * dt - angleBias;

	return;
}

//Combines all the sensor values for the PID controller
float combineSensorValues(float angularVelocity, float robotAngle,float robotPosition,float robotSpeed){


	return
	( robotPosition - balanceRobotPosition) * balanceRobotPosition +
	robotSpeed * balanceRobotSpeed + robotAngle +
	+ angle + angularVelocity *
	angularVelocity;
}

//PID learns from previous error and takes into consideration current state and future state.
//Note: SAMPLE_TIME used in EV3 blocks however i'm unaware what its used for so it is currently left out.
float pid(float input, float referenceValue){
	// static float definitions
	static float totalError = 0.0; // total error up till current.
	static float derivative = 0.0; // 'D' of PID.
	static float integral = 0.0; // 'I' of PID, past error.

	float presentError = input - referenceValue; // 'P' of PID.
	totalError += dt * presentError;
	derivative = (presentError - integral) / dt;
	integral = presentError; // set present error to past error for next loop

	return ((kd * derivative) + (totalError * ki) + (presentError * kp));
}

void setMotorPower(float power){

	if(power > MAX_POWER){  //was using POWER_LIMIT but wasn't defined, changed it to MAX_POWER
		power = MAX_POWER;
		} else if(power < -MAX_POWER){
		power = -MAX_POWER;
	}
	setMotor(rightMotor,power);
	setMotor(leftMotor,power);
}

// checks for unaccurate PID output, the result of pid function is passed to this function.
void errors(float output){
	//Currently uses global variables TODO: static local variables?
	if(abs( output) > 100){
		outOfBounds = true;
	}

	if( outOfBounds && prevOutOfBounds){
		outOfBoundsCounter++;
		} else {
		outOfBoundsCounter = 0;
	}

	if(outOfBoundsCounter > 20) {
		setMotorPower(0);
		sleep(100);
	}
}


//TODO driver code
task main(){

	int increment = 0;
	//PID values
	float pidReference = 0.0; //TODO

	//Values for position
	float referencePosition = 0.0;
	float requestedSpeed = 0.0; //TODO

	float sensors = combineSensorValues(angularVelocity,angle, robotPosition, robotSpeed);

	// constants variable
	//constants values;


	initialize();
	//values = setConstants();

	/* !----Loop-----! */
	resetTimer(T1);
	resetTimer(T2);

	referencePosition = position(referencePosition,requestedSpeed);
	readEncoders(); // update state of robot
	readGyro();
	sensors = combineSensorValues(angularVelocity,angle, robotPosition, robotSpeed);

	//PID
	pidOutput = pid(sensors,pidReference);
	errors(pidOutput);
	setMotorPower(pidOutput);

	increment++;

	repeatUntil(getTimer(T2,milliseconds) > SAMPLE_TIME){}
	resetTimer(T2);
}
