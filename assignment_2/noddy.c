#pragma config(Sensor, S1,     touchSensor,    sensorNone)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorNone)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,				     tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Code written by Group 5, for assignment 2 of COMP20170: Introduction to Robotics

/* Aims to make intial gyro reading consistent, by setting the gyro to zero when the robot is flat
 on its back, and  then setting the offset to +/-90 (we found 85 works best), */
void initializeGyro() {
	eraseDisplay();
	displayCenteredBigTextLine(2,"Place flat on table");
	sleep(4000);
	resetGyro(gyroSensor);
	eraseDisplay();
	displayCenteredBigTextLine(2, "Complete.");
	playSound(soundUpwardTones);
	sleep(4000);
}

float PID(float error) {

  // floats for tracking previous error
	static float integral = 0;
	static float derivative = 0;
	static float lastError = 0;

	float targetPower = 0; // i.e. not moving when balanced
	float offset = 85;

  // Values calculated using Zieglerâ€“Nichols method and then adjusted with trial and error.
	float kp = 16;
	float ki = 0.0000075;
	float kd = 55;

	error = error - offset;
	integral = integral + error;
	derivative = error - lastError;

	float tilt = (kp * error) + (ki * integral) + (kd * derivative); // power needed to correct current tilt
	lastError=error;
	return (tilt + targetPower);
}

void setBothMotors(float power) {
	setMotorSpeed(leftMotor,power);
	setMotorSpeed(rightMotor,power);
}

task main() {
	initializeGyro();

	eraseDisplay();
	while(1){

		if(getGyroDegrees(gyroSensor) == 0){
			displayCenteredBigTextLine(2,"Balanced!"); }
		else if(getGyroDegrees(gyroSensor) > 0){
			displayCenteredBigTextLine(2,"Falling\n forward"); }
		else if(getGyroDegrees(gyroSensor) < 0){
			displayCenteredBigTextLine(2,"Falling\n backward"); }

		float power = PID(getGyroDegrees(gyroSensor));

		displayCenteredBigTextLine(6,"Power: %f",power);
		setBothMotors(power);
	}
}
