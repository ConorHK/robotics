#pragma config(Sensor, S1,     touchSensor,    sensorNone)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorNone)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float getGyroBias(){
	float gyroBias = 0.0;
  int readings = 100;

  eraseDisplay();
  displayCenteredBigTextLine(2,"Calibrating...");
	resetGyro( gyroSensor );
  sleep(1000);

	for(int i = 0; i < 100; i++){
		gyroBias += getGyroRate(gyroSensor);
    sleep(5);
	}
	gyroBias = gyroBias / 100; //get average
	return 	gyroBias;

}

task main()
{
  float gyroRateBias = getGyroBias();
	float kp = 14; // Constant for proportional controllor
	float ki = 2;
	float kd = 1;
	float offset = 0;
	float tp = 0;
	float integral = 0;
	float lasterror = 0;
	float derivative = 0;
	while(!getButtonPress(buttonEnter)){

		float gyrovalue = getGyroDegrees(S2);
		float error = gyrovalue - offset;
		integral = integral + error;
		derivative = error - lasterror;
		float Tilt = kp * error + ki*integral + kd*derivative;
		float powerA = tp + Tilt;
		setMotorSpeed(motorA,powerA);
		setMotorSpeed(motorC,powerA);
		lasterror = error;
		timer++;
	}


}
